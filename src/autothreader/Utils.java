package autothreader;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Random;

import com.google.common.collect.Lists;

import soot.Body;
import soot.Local;
import soot.Modifier;
import soot.PatchingChain;
import soot.Scene;
import soot.SootClass;
import soot.SootField;
import soot.SootMethod;
import soot.SourceLocator;
import soot.Type;
import soot.Unit;
import soot.Value;
import soot.VoidType;
import soot.jimple.AssignStmt;
import soot.jimple.CastExpr;
import soot.jimple.IdentityStmt;
import soot.jimple.InterfaceInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.InvokeStmt;
import soot.jimple.JasminClass;
import soot.jimple.Jimple;
import soot.jimple.SpecialInvokeExpr;
import soot.jimple.StaticInvokeExpr;
import soot.jimple.toolkits.scalar.pre.SootFilter;
import soot.options.Options;
import soot.util.JasminOutputStream;

public class Utils {
	private static Utils instance = new Utils();
	
	private static Random rand = new Random();
	
	public static Utils v() {
		return instance;
	}
	
	public SootMethod createClinit() {
		SootMethod clinit = new SootMethod(SootMethod.staticInitializerName, new ArrayList<Type>(), VoidType.v(), Modifier.STATIC);
		Body body = Jimple.v().newBody(clinit);
		clinit.setActiveBody(body);
		body.getUnits().add(Jimple.v().newReturnVoidStmt());
		return clinit;
	}
	
	public SootField createEsField() {
		SootClass executorServiceClass = Scene.v().getSootClass("java.util.concurrent.ExecutorService");
		return new SootField("_autogenerated_$es", executorServiceClass.getType(), Modifier.STATIC);
	}
	
	public void addExecutorField(Body body, PatchingChain<Unit> pc) {
		assert SootMethod.staticInitializerName.equals(body.getMethod().getName());
		
		SootClass executorsClass = Scene.v().getSootClass("java.util.concurrent.Executors");
		
		SootField esField = body.getMethod().getDeclaringClass().getFieldByName("_autogenerated_$es");
		
		Local esLocal = Jimple.v().newLocal("temp$es", esField.getType());
		body.getLocals().add(esLocal);
		StaticInvokeExpr invokeExpr = Jimple.v().newStaticInvokeExpr(executorsClass.getMethod("newCachedThreadPool", new ArrayList<Type>()).makeRef());
		AssignStmt tmpAssignStmt = Jimple.v().newAssignStmt(esLocal, invokeExpr);
		
		AssignStmt assignStmt = Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(esField.makeRef()), esLocal);
		
		pc.insertBefore(tmpAssignStmt, pc.getLast());
		pc.insertBefore(assignStmt, pc.getLast());
	}
	
	public Local addEsLocal(Body body, PatchingChain<Unit> pc) {
		SootField esField = body.getMethod().getDeclaringClass().getFieldByName("_autogenerated_$es");
		Local esLocal = Jimple.v().newLocal("temp$es", esField.getType());
		body.getLocals().add(esLocal);
		AssignStmt assignStmt = Jimple.v().newAssignStmt(esLocal, Jimple.v().newStaticFieldRef(esField.makeRef()));

		pc.insertAfter(assignStmt, pc.getFirst());
		
		return esLocal;
	}
	
	public void addFinalizer(Body body, Local esLocal, PatchingChain<Unit> pc) {
		assert "main".equals(body.getMethod().getName());
		
		SootClass executorServiceClass = Scene.v().getSootClass("java.util.concurrent.ExecutorService");
		
		InterfaceInvokeExpr invokeExpr = Jimple.v().newInterfaceInvokeExpr(esLocal, executorServiceClass.getMethodByName("shutdown").makeRef());
		InvokeStmt invokeStmt = Jimple.v().newInvokeStmt(invokeExpr);
		
		pc.insertBefore(invokeStmt, pc.getLast());
	}
	
	public void toThread(Body body, Unit unit, Local esLocal, PatchingChain<Unit> pc) {
		AssignStmt stmt = (AssignStmt) unit;
		
		SootClass anonClass = createCallableClass(body.getMethod().getDeclaringClass(), stmt); 
		Scene.v().addClass(anonClass);
		try {
			writeClassFile(anonClass);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		
		Local callableInstance = Jimple.v().newLocal("temp$callable" + Math.abs(rand.nextInt()), anonClass.getInterfaces().getFirst().getType());
		body.getLocals().add(callableInstance);
		AssignStmt assignStmt = Jimple.v().newAssignStmt(callableInstance, Jimple.v().newNewExpr(anonClass.getType()));
		pc.insertBefore(assignStmt, unit);

		SpecialInvokeExpr invokeCtorExpr = Jimple.v().newSpecialInvokeExpr(callableInstance, anonClass.getMethodByName("<init>").makeRef());
		InvokeStmt invokeCtorStmt = Jimple.v().newInvokeStmt(invokeCtorExpr);
		pc.insertBefore(invokeCtorStmt, unit);

		SootClass executorServiceClass = Scene.v().getSootClass("java.util.concurrent.ExecutorService");
		SootClass callableClass = Scene.v().getSootClass("java.util.concurrent.Callable");
		SootMethod submitMethod = executorServiceClass.getMethod("submit", Lists.<Type>newArrayList(callableClass.getType()));
		InterfaceInvokeExpr submitExpr = Jimple.v().newInterfaceInvokeExpr(esLocal, submitMethod.makeRef(), callableInstance);
		Local futureLocal = Jimple.v().newLocal("temp$future" + Math.abs(rand.nextInt()), submitMethod.getReturnType());
		body.getLocals().add(futureLocal);
		AssignStmt assignFuture = Jimple.v().newAssignStmt(futureLocal, submitExpr);
		pc.insertBefore(assignFuture, unit);

		Unit originalAssignToLocal = pc.getSuccOf(unit);
		Local local = (Local) ((AssignStmt) originalAssignToLocal).getLeftOp();
		local.setType(submitMethod.getReturnType());
		
		AssignStmt newAssignToLocal = Jimple.v().newAssignStmt(local, futureLocal);
		pc.insertAfter(newAssignToLocal, unit);
		
		pc.remove(unit);
		pc.remove(originalAssignToLocal);
	}
	
	public void fixCallsite(Body body, Unit unit, Value arg, Type type, PatchingChain<Unit> pc) {
		assert SootFilter.isLocal(arg);
		
		SootClass futureClass = Scene.v().getSootClass("java.util.concurrent.Future");
		SootMethod getMethod = futureClass.getMethod("get", new ArrayList<Type>());
		InterfaceInvokeExpr getExpr = Jimple.v().newInterfaceInvokeExpr((Local) arg, getMethod.makeRef());
		Local getLocal = Jimple.v().newLocal("temp$get" + Math.abs(rand.nextInt()), getMethod.getReturnType());
		body.getLocals().add(getLocal);
		AssignStmt assignGet = Jimple.v().newAssignStmt(getLocal, getExpr);
		pc.insertBefore(assignGet, unit);
		
		CastExpr castExpr = Jimple.v().newCastExpr(getLocal, type);
		Local valueLocal = Jimple.v().newLocal("temp$value" + Math.abs(rand.nextInt()), type);
		body.getLocals().add(valueLocal);
		AssignStmt assignValue = Jimple.v().newAssignStmt(valueLocal, castExpr);
		pc.insertBefore(assignValue, unit);
		
		// Assuming this is an invokeExpr. Need to do cases here...
		InvokeExpr invokeExpr = ((InvokeStmt) unit).getInvokeExpr();
		invokeExpr.setArg(invokeExpr.getArgs().indexOf(arg), valueLocal);
		((InvokeStmt) unit).setInvokeExpr(invokeExpr);
	}
	
	private void writeClassFile(SootClass cls) throws IOException {
		String fileName = SourceLocator.v().getFileNameFor(cls, Options.output_format_class);
		new File(new File(fileName).getParent()).mkdirs();
		OutputStream streamOut = new JasminOutputStream(new FileOutputStream(fileName));
		PrintWriter writerOut = new PrintWriter(new OutputStreamWriter(streamOut));
		JasminClass jasminClass = new soot.jimple.JasminClass(cls);
		jasminClass.print(writerOut);
		writerOut.flush();
		streamOut.close();
	}
	
	private SootClass createCallableClass(SootClass containingClass, AssignStmt stmt) {
		SootClass callableClass = Scene.v().getSootClass("java.util.concurrent.Callable");
		String methodSignature = stmt.getInvokeExpr().getMethod().getSignature();

		SootClass anonClass = new SootClass(
				containingClass.getName() + "$_Anonymous" + Math.abs(methodSignature.hashCode()), Modifier.PRIVATE);
		anonClass.addInterface(callableClass);
		anonClass.setSuperclass(Scene.v().getSootClass("java.lang.Object"));
		anonClass.addMethod(createEmptyCtor(anonClass));
		anonClass.addMethod(createCallMethod(anonClass, stmt.getInvokeExpr()));
		
		return anonClass;
	}
	
	private SootMethod createEmptyCtor(SootClass cls) {
		SootMethod initMethod = new SootMethod(SootMethod.constructorName, new ArrayList<Type>(), VoidType.v(), Modifier.PUBLIC);
		Body body = Jimple.v().newBody(initMethod);
		initMethod.setActiveBody(body);
		
		PatchingChain<Unit> units = body.getUnits();
		
		Local self = Jimple.v().newLocal("this", cls.getType());
		body.getLocals().add(self);
		IdentityStmt selfInit = Jimple.v().newIdentityStmt(
				self, Jimple.v().newThisRef(cls.getType()));
		units.add(selfInit);
		
		SootClass parentClass = cls.getSuperclass();
		InvokeStmt invokeParent = Jimple.v().newInvokeStmt(
				Jimple.v().newSpecialInvokeExpr(body.getThisLocal(), parentClass.getMethodByName(SootMethod.constructorName).makeRef()));
		units.add(invokeParent);
		
		units.add(Jimple.v().newReturnVoidStmt());
		return initMethod;
	}
	
	private SootMethod createCallMethod(SootClass cls, InvokeExpr expr) {
		//SootMethod callMethod = new SootMethod("call", new ArrayList<Type>(), expr.getType(), Modifier.PUBLIC);
		SootMethod callMethod = new SootMethod("call", new ArrayList<Type>(), Scene.v().getType("java.lang.Object"), Modifier.PUBLIC);
		callMethod.addException(Scene.v().getSootClass("java.lang.Exception"));
		Body body = Jimple.v().newBody(callMethod);
		callMethod.setActiveBody(body);
		
		PatchingChain<Unit> units = body.getUnits();
		
		Local self = Jimple.v().newLocal("this", cls.getType());
		body.getLocals().add(self);
		IdentityStmt selfInit = Jimple.v().newIdentityStmt(
				self, Jimple.v().newThisRef(cls.getType()));
		units.add(selfInit);
		
		Local retvalLocal = Jimple.v().newLocal("temp$retval", expr.getType());
		body.getLocals().add(retvalLocal);
		
		AssignStmt assignStmt = Jimple.v().newAssignStmt(retvalLocal, expr);
		Unit return_unit = Jimple.v().newReturnStmt(retvalLocal);
		units.add(assignStmt);
	    units.add(return_unit);
	    
		return callMethod;
	}
}
