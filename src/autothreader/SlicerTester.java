package autothreader;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;

import slicers.JimpleFutureTagger;
import slicers.SimpleJimpleSlicer;
import soot.Body;
import soot.BodyTransformer;
import soot.Modifier;
import soot.PackManager;
import soot.PatchingChain;
import soot.Scene;
import soot.SootClass;
import soot.SootField;
import soot.SootMethod;
import soot.Transform;
import soot.Type;
import soot.Unit;
import soot.VoidType;
import soot.jimple.AssignStmt;
import soot.jimple.Jimple;

public class SlicerTester {
	public static final void main(String[] args) throws IOException {
		String srcPath = System.getProperty("os.name").toLowerCase().contains("windows") ? ";.\\src" : ":./src";// for

		Scene.v().setSootClassPath(Scene.v().defaultClassPath() + srcPath);
		System.out.println(Scene.v().getSootClassPath());

		SootClass c = Scene.v().loadClassAndSupport("test.Test3");
		Scene.v().addBasicClass("java.util.concurrent.ExecutorService", SootClass.SIGNATURES);
		Scene.v().addBasicClass("java.util.concurrent.Executors", SootClass.SIGNATURES);
		Scene.v().loadNecessaryClasses();
		c.setApplicationClass();

		if (!c.declaresMethodByName("<clinit>")) {
			SootMethod clinit = new SootMethod("<clinit>", new ArrayList<Type>(), VoidType.v(), Modifier.STATIC);
			Body body = Jimple.v().newBody(clinit);
			clinit.setActiveBody(body);
			PatchingChain<Unit> units = body.getUnits();
			Unit return_unit = Jimple.v().newReturnVoidStmt();
			units.add(return_unit);
			c.addMethod(clinit);
		}

		SootClass executorServiceClass = Scene.v().getSootClass("java.util.concurrent.ExecutorService");
		SootField esField = new SootField("_autogenerated_$es", executorServiceClass.getType(), Modifier.STATIC);
		c.addField(esField);
		// SootMethod m = c.getMethodByName("main");
		// Body b = m.retrieveActiveBody();

		PackManager.v().getPack("jtp").add(new Transform("jtp.Threadalizer", new Transformer()));
		PackManager.v().runPacks();
		PackManager.v().writeOutput();

		// Transformer t = new Transformer();
		// t.transform(b);
		/*
		 * UnitGraph g = new ExceptionalUnitGraph(b); for (Unit u : g) {
		 * List<ValueBox> boxes = u.getUseBoxes(); System.out.print(u +
		 * " -=-= : "); for (ValueBox box : boxes) { System.out.print(box + ", "
		 * ); } System.out.println("\n"); }
		 */
	}

	public static class Transformer extends BodyTransformer {
		@Override
		protected void internalTransform(Body b, String phaseName, Map<String, String> options) {
			assert "main".equals(b.getMethod().getName());
			
			System.out.println("TRANSFORM!");
			SimpleJimpleSlicer sjp = new SimpleJimpleSlicer(b);
			for(Unit u:b.getUnits())
				if(u instanceof AssignStmt)
					sjp.slice(u);
			//JimpleFutureTagger jft = new JimpleFutureTagger(b);
			System.out.println("Transform done.");

		}

	}
}
